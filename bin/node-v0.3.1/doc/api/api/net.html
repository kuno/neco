<!DOCTYPE html>
<html>
<head>
  <title>net - Node.js Manual &amp; Documentation</title>
  <link rel="stylesheet" href="assets/style.css" type="text/css" media="all" />
  <link rel="stylesheet" href="assets/sh.css" type="text/css" media="all"/>
  <script type="text/javascript" src="assets/jquery.js"></script>
</head>
<body>
  <div id="container">
    <header>
      <h1>Node.js Manual &amp; Documentation</h1>
      <div id="gtoc">
        <p><a href="index.html">Index</a> | <a href="all.html">View on single page</a></p>
      </div>
      <hr />
    </header>
    <h2 id="net">net</h2>

<p>The <code>net</code> module provides you with an asynchronous network wrapper. It contains
methods for creating both servers and clients (called streams). You can include 
this module with <code>require("net");</code></p>

<h3 id="net.createServer">net.createServer(connectionListener)</h3>

<p>Creates a new TCP server. The <code>connectionListener</code> argument is
automatically set as a listener for the <code>'connection'</code> event.</p>

<h3 id="net.createConnection">net.createConnection(arguments...)</h3>

<p>Construct a new stream object and opens a stream to the given location. When
the stream is established the <code>'connect'</code> event will be emitted.</p>

<p>The arguments for this method change the type of connection:</p>

<ul><li><p><code>net.createConnection(port, [host])</code></p><p>Creates a TCP connection to <code>port</code> on <code>host</code>. If <code>host</code> is omitted, <code>localhost</code>
will be assumed.</p></li><li><p><code>net.createConnection(path)</code></p><p>Creates unix socket connection to <code>path</code></p></li></ul>

<hr />

<h3 id="net.Server">net.Server</h3>

<p>This class is used to create a TCP or UNIX server.</p>

<p>Here is an example of a echo server which listens for connections
on port 8124:</p>

<pre><code>var net = require('net');
var server = net.createServer(function (stream) {
  stream.setEncoding('utf8');
  stream.on('connect', function () {
    stream.write('hello\r\n');
  });
  stream.on('data', function (data) {
    stream.write(data);
  });
  stream.on('end', function () {
    stream.write('goodbye\r\n');
    stream.end();
  });
});
server.listen(8124, 'localhost');</code></pre>

<p>To listen on the socket <code>'/tmp/echo.sock'</code>, the last line would just be
changed to</p>

<pre><code>server.listen('/tmp/echo.sock');</code></pre>

<p>This is an <code>EventEmitter</code> with the following events:</p>

<h4 id="server.listen">server.listen(port, [host], [callback])</h4>

<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).</p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.</p>

<h4 id="server.listen">server.listen(path, [callback])</h4>

<p>Start a UNIX socket server listening for connections on the given <code>path</code>.</p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.</p>

<h4 id="server.listenFD">server.listenFD(fd)</h4>

<p>Start a server listening for connections on the given file descriptor.</p>

<p>This file descriptor must have already had the <code>bind(2)</code> and <code>listen(2)</code> system
calls invoked on it.</p>

<h4 id="server.close">server.close()</h4>

<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code>'close'</code>
event.</p>

<h4 id="server.address">server.address()</h4>

<p>Returns the bound address of the server as seen by the operating system.
Useful to find which port was assigned when giving getting an OS-assigned address</p>

<p>Example:</p>

<pre><code>var server = net.createServer(function (socket) {
  socket.end("goodbye\n");
});

// grab a random port.
server.listen(function() {
  address = server.address();
  console.log("opened server on %j", address);
});</code></pre>

<h4 id="server.maxConnections">server.maxConnections</h4>

<p>Set this property to reject connections when the server's connection count gets high.</p>

<h4 id="server.connections">server.connections</h4>

<p>The number of concurrent connections on the server.</p>

<h4 id="event_connection_">Event: 'connection'</h4>

<p><code>function (stream) {}</code></p>

<p>Emitted when a new connection is made. <code>stream</code> is an instance of
<code>net.Stream</code>.</p>

<h4 id="event_close_">Event: 'close'</h4>

<p><code>function () {}</code></p>

<p>Emitted when the server closes.</p>

<hr />

<h3 id="net.Stream">net.Stream</h3>

<p>This object is an abstraction of of a TCP or UNIX socket.  <code>net.Stream</code>
instance implement a duplex stream interface.  They can be created by the
user and used as a client (with <code>connect()</code>) or they can be created by Node
and passed to the user through the <code>'connection'</code> event of a server.</p>

<p><code>net.Stream</code> instances are EventEmitters with the following events:</p>

<h4 id="stream.connect">stream.connect(port, [host])</h4>

<h4 id="stream.connect">stream.connect(path)</h4>

<p>Opens the connection for a given stream. If <code>port</code> and <code>host</code> are given,
then the stream will be opened as a TCP stream, if <code>host</code> is omitted,
<code>localhost</code> will be assumed. If a <code>path</code> is given, the stream will be
opened as a unix socket to that path.</p>

<p>Normally this method is not needed, as <code>net.createConnection</code> opens the
stream. Use this only if you are implementing a custom Stream or if a
Stream is closed and you want to reuse it to connect to another server.</p>

<p>This function is asynchronous. When the <code>'connect'</code> event is emitted the
stream is established. If there is a problem connecting, the <code>'connect'</code>
event will not be emitted, the <code>'error'</code> event will be emitted with
the exception.</p>

<h4 id="stream.setEncoding">stream.setEncoding(encoding=null)</h4>

<p>Sets the encoding (either <code>'ascii'</code>, <code>'utf8'</code>, or <code>'base64'</code>) for data that is
received.</p>

<h4 id="stream.setSecure">stream.setSecure([credentials])</h4>

<p>Enables SSL support for the stream, with the crypto module credentials specifying
the private key and certificate of the stream, and optionally the CA certificates
for use in peer authentication.</p>

<p>If the credentials hold one ore more CA certificates, then the stream will request
for the peer to submit a client certificate as part of the SSL connection handshake.
The validity and content of this can be accessed via verifyPeer() and getPeerCertificate().</p>

<h4 id="stream.verifyPeer">stream.verifyPeer()</h4>

<p>Returns true or false depending on the validity of the peers's certificate in the
context of the defined or default list of trusted CA certificates.</p>

<h4 id="stream.getPeerCertificate">stream.getPeerCertificate()</h4>

<p>Returns a JSON structure detailing the peer's certificate, containing a dictionary
with keys for the certificate 'subject', 'issuer', 'valid_from' and 'valid_to'</p>

<h4 id="stream.write">stream.write(data, encoding='ascii')</h4>

<p>Sends data on the stream. The second parameter specifies the encoding in
the case of a string--it defaults to ASCII because encoding to UTF8 is rather
slow.</p>

<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel
buffer. Returns <code>false</code> if all or part of the data was queued in user memory.
<code>'drain'</code> will be emitted when the buffer is again free.</p>

<h4 id="stream.end">stream.end([data], [encoding])</h4>

<p>Half-closes the stream. I.E., it sends a FIN packet. It is possible the
server will still send some data. After calling this <code>readyState</code> will be
<code>'readOnly'</code>.</p>

<p>If <code>data</code> is specified, it is equivalent to calling <code>stream.write(data, encoding)</code>
followed by <code>stream.end()</code>.</p>

<h4 id="stream.destroy">stream.destroy()</h4>

<p>Ensures that no more I/O activity happens on this stream. Only necessary in
case of errors (parse error or so).</p>

<h4 id="stream.pause">stream.pause()</h4>

<p>Pauses the reading of data. That is, <code>'data'</code> events will not be emitted.
Useful to throttle back an upload.</p>

<h4 id="stream.resume">stream.resume()</h4>

<p>Resumes reading after a call to <code>pause()</code>.</p>

<h4 id="stream.setTimeout">stream.setTimeout(timeout)</h4>

<p>Sets the stream to timeout after <code>timeout</code> milliseconds of inactivity on
the stream. By default <code>net.Stream</code> do not have a timeout.</p>

<p>When an idle timeout is triggered the stream will receive a <code>'timeout'</code>
event but the connection will not be severed. The user must manually <code>end()</code>
or <code>destroy()</code> the stream.</p>

<p>If <code>timeout</code> is 0, then the existing idle timeout is disabled.</p>

<h4 id="stream.setNoDelay">stream.setNoDelay(noDelay=true)</h4>

<p>Disables the Nagle algorithm. By default TCP connections use the Nagle
algorithm, they buffer data before sending it off. Setting <code>noDelay</code> will
immediately fire off data each time <code>stream.write()</code> is called.</p>

<h4 id="stream.setKeepAlive">stream.setKeepAlive(enable=false, [initialDelay])</h4>

<p>Enable/disable keep-alive functionality, and optionally set the initial
delay before the first keepalive probe is sent on an idle stream.
Set <code>initialDelay</code> (in milliseconds) to set the delay between the last
data packet received and the first keepalive probe. Setting 0 for
initialDelay will leave the value unchanged from the default
(or previous) setting.</p>

<h4 id="stream.remoteAddress">stream.remoteAddress</h4>

<p>The string representation of the remote IP address. For example,
<code>'74.125.127.100'</code> or <code>'2001:4860:a005::68'</code>.</p>

<p>This member is only present in server-side connections.</p>

<h4 id="stream.readyState">stream.readyState</h4>

<p>Either <code>'closed'</code>, <code>'open'</code>, <code>'opening'</code>, <code>'readOnly'</code>, or <code>'writeOnly'</code>.</p>

<h4 id="event_connect_">Event: 'connect'</h4>

<p><code>function () { }</code></p>

<p>Emitted when a stream connection successfully is established.
See <code>connect()</code>.</p>

<h4 id="event_secure_">Event: 'secure'</h4>

<p><code>function () { }</code></p>

<p>Emitted when a stream connection successfully establishes an SSL handshake with its peer.</p>

<h4 id="event_data_">Event: 'data'</h4>

<p><code>function (data) { }</code></p>

<p>Emitted when data is received.  The argument <code>data</code> will be a <code>Buffer</code> or
<code>String</code>.  Encoding of data is set by <code>stream.setEncoding()</code>.
(See the section on <code>Readable Stream</code> for more information.)</p>

<h4 id="event_end_">Event: 'end'</h4>

<p><code>function () { }</code></p>

<p>Emitted when the other end of the stream sends a FIN packet.</p>

<p>By default (<code>allowHalfOpen == false</code>) the stream will destroy its file
descriptor  once it has written out its pending write queue.  However, by
setting <code>allowHalfOpen == true</code> the stream will not automatically <code>end()</code>
its side allowing the user to write arbitrary amounts of data, with the
caveat that the user is required to <code>end()</code> their side now. In the
<code>allowHalfOpen == true</code> case after <code>'end'</code> is emitted the <code>readyState</code> will
be <code>'writeOnly'</code>.</p>

<h4 id="event_timeout_">Event: 'timeout'</h4>

<p><code>function () { }</code></p>

<p>Emitted if the stream times out from inactivity. This is only to notify that
the stream has been idle. The user must manually close the connection.</p>

<p>See also: <code>stream.setTimeout()</code></p>

<h4 id="event_drain_">Event: 'drain'</h4>

<p><code>function () { }</code></p>

<p>Emitted when the write buffer becomes empty. Can be used to throttle uploads.</p>

<h4 id="event_error_">Event: 'error'</h4>

<p><code>function (exception) { }</code></p>

<p>Emitted when an error occurs.  The <code>'close'</code> event will be called directly
following this event.</p>

<h4 id="event_close_">Event: 'close'</h4>

<p><code>function (had_error) { }</code></p>

<p>Emitted once the stream is fully closed. The argument <code>had_error</code> is a boolean which says if
the stream was closed due to a transmission
error.</p>

<hr />

<h3 id="net.isIP">net.isIP</h3>

<h4 id="net.isIP">net.isIP(input)</h4>

<p>Tests if input is an IP address. Returns 0 for invalid strings,
returns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses.</p>

<h4 id="net.isIPv4">net.isIPv4(input)</h4>

<p>Returns true if input is a version 4 IP address, otherwise returns false.</p>

<h4 id="net.isIPv6">net.isIPv6(input)</h4>

<p>Returns true if input is a version 6 IP address, otherwise returns false.</p>
  </div>
  <script type="text/javascript" src="assets/sh_main.js"></script>
  <script type="text/javascript" src="assets/sh_javascript.min.js"></script>
  <script type="text/javascript" src="assets/core.js"></script>
</body>
</html>